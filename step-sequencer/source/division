sequencer_utils.c:93:34://    float phaseLength = ((60 / self->bpm) / ((rateValues[(int)division] / 2)));
sequencer_utils.c:94:30://    float pos = fmod((60 / self->bpm) * self->beatInMeasure, phaseLength) / phaseLength;
sequencer_utils.c:100:20://    debug_print("self->beatInMeasure = %f\n", self->beatInMeasure);
sequencer_utils.c:118:9:        self->placementIndex = 1;
sequencer_utils.c:120:9:        self->placementIndex = 0;
sequencer_utils.c:130:9:    if (self->division != self->previousDevision) {
sequencer_utils.c:131:43:        float noteLengthInSeconds = 1.0 / self->frequency;
sequencer_utils.c:132:9:        self->phase        = calculateNewPhase(self, noteLengthInSeconds, self->beatInMeasure, self->bpm);
sequencer_utils.c:133:9:        self->previousDevision = self->divisionRate;
sequencer_utils.c:136:9:    if (self->beatInMeasure < 0.5 && self->resetPhase) {
sequencer_utils.c:139:13:        if (self->playing != self->previousPlaying) {
sequencer_utils.c:140:18:            if (*self->modeParam > 1) {
sequencer_utils.c:141:17:                self->velPhase = velInitVal;
sequencer_utils.c:142:17:                self->firstBar = true;
sequencer_utils.c:144:13:            self->previousPlaying = self->playing;
sequencer_utils.c:147:13:        if (self->phase > 0.989 || self->phase < 0.01) {
sequencer_utils.c:148:13:            self->phase = 0.0;
sequencer_utils.c:151:9:        self->resetPhase  = false;
sequencer_utils.c:154:13:        if (self->beatInMeasure > 0.5) {
sequencer_utils.c:155:13:            self->resetPhase = true;

Step-Sequencer.c:53:5:    self->urid_midiEvent = map->map(map->handle, LV2_MIDI__MidiEvent);
Step-Sequencer.c:55:34:    MetroURIs* const    uris  = &self->uris;
Step-Sequencer.c:68:5:    self->rate             = rate;
Step-Sequencer.c:69:5:    self->nyquist          = rate / 2; 
Step-Sequencer.c:70:5:    self->bpm              = 120.0f;
Step-Sequencer.c:71:5:    self->beatInMeasure    = 0;
Step-Sequencer.c:72:5:    self->divisionRate     = 4;
Step-Sequencer.c:73:5:    self->phase            = 0;
Step-Sequencer.c:74:5:    self->velPhase         = 0.000000009;
Step-Sequencer.c:75:5:    self->x1               = 0.00000001; 
Step-Sequencer.c:76:5:    self->velocityLFO      = 0;
Step-Sequencer.c:77:5:    self->velocity         = 0;
Step-Sequencer.c:78:5:    self->octaveIndex      = 0;
Step-Sequencer.c:79:5:    self->noteOffIndex     = 0; 
Step-Sequencer.c:80:5:    self->noteOffSendIndex = 0; 
Step-Sequencer.c:81:5:    self->countTicks       = 0;
Step-Sequencer.c:82:5:    self->patternIndex     = 0;
Step-Sequencer.c:83:5:    self->modeHandle       = 0;
Step-Sequencer.c:84:5:    self->prevMod          = 100;
Step-Sequencer.c:85:5:    self->prevLatch        = 100;
Step-Sequencer.c:86:5:    self->count            = 0;
Step-Sequencer.c:87:5:    self->inputIndex       = 0;
Step-Sequencer.c:88:5:    self->notesPressed     = 0;
Step-Sequencer.c:90:5:    self->prevThrough      = 0;
Step-Sequencer.c:92:5:    self->placementIndex   = 0;
Step-Sequencer.c:93:5:    self->notePlacement[0] = 0;
Step-Sequencer.c:94:5:    self->notePlacement[1] = 0.5;
Step-Sequencer.c:97:5:    self->previousDevision = 12;
Step-Sequencer.c:98:5:    self->previousPlaying = false;
Step-Sequencer.c:99:5:    self->resetPhase      = true;
Step-Sequencer.c:102:9:        self->midiThroughInput[i] = 0;
Step-Sequencer.c:107:5:    self->writeEvents  = (Array* )malloc(sizeof(Array));
Step-Sequencer.c:108:5:    self->playEvents   = (Array* )malloc(sizeof(Array));
Step-Sequencer.c:111:9:        self->noteOffArr[i] = 0;
Step-Sequencer.c:116:13:            self->noteOffTimer[row][index] = 0;
Step-Sequencer.c:120:5:    self->writeEvents->used  = 0;
Step-Sequencer.c:121:5:    self->playEvents->used   = 0;
Step-Sequencer.c:123:5:    self->notePlayed  = 0;
Step-Sequencer.c:124:5:    self->transpose   = 0;
Step-Sequencer.c:125:5:    self->lfo1        = 0;  
Step-Sequencer.c:126:5:    self->lfo2        = 0;  
Step-Sequencer.c:128:5:    self->firstRecordedNote = false; 
Step-Sequencer.c:129:5:    self->trigger           = false;
Step-Sequencer.c:130:5:    self->triggerSet        = false;
Step-Sequencer.c:131:5:    self->cleared           = true; 
Step-Sequencer.c:132:5:    self->through           = true;
Step-Sequencer.c:133:5:    self->firstBar          = false;
Step-Sequencer.c:134:5:    self->playing           = false;
Step-Sequencer.c:135:5:    self->clip              = false;
Step-Sequencer.c:137:5:    self->parameters[0]   = NULL;
Step-Sequencer.c:138:5:    self->parameters[1]   = &self->divisionParam;
Step-Sequencer.c:139:5:    self->parameters[2]   = &self->noteLengthParam;
Step-Sequencer.c:140:5:    self->parameters[3]   = &self->octaveSpreadParam;
Step-Sequencer.c:141:5:    self->parameters[4]   = &self->swingParam;
Step-Sequencer.c:142:5:    self->parameters[5]   = &self->randomizeTimmingParam;
Step-Sequencer.c:143:5:    self->parameters[6]   = &self->velocityModeParam;
Step-Sequencer.c:144:5:    self->parameters[7]   = &self->velocityCurveParam;
Step-Sequencer.c:145:5:    self->parameters[8]   = &self->curveDepthParam;
Step-Sequencer.c:146:5:    self->parameters[9]   = &self->curveClipParam;
Step-Sequencer.c:147:5:    self->parameters[10]  = &self->patternVel1Param;
Step-Sequencer.c:148:5:    self->parameters[11]  = &self->patternVel2Param;
Step-Sequencer.c:149:5:    self->parameters[12]  = &self->patternVel3Param;
Step-Sequencer.c:150:5:    self->parameters[13]  = &self->patternVel4Param;
Step-Sequencer.c:151:5:    self->parameters[14]  = &self->patternVel5Param;
Step-Sequencer.c:152:5:    self->parameters[15]  = &self->patternVel6Param;
Step-Sequencer.c:153:5:    self->parameters[16]  = &self->patternVel7Param;
Step-Sequencer.c:154:5:    self->parameters[17]  = &self->patternVel8Param;
Step-Sequencer.c:169:13:            self->port_events_in = (const LV2_Atom_Sequence*)data;
Step-Sequencer.c:172:13:            self->port_events_out1 = (LV2_Atom_Sequence*)data;
Step-Sequencer.c:175:13:            self->control = (LV2_Atom_Sequence*)data;
Step-Sequencer.c:178:13:            self->lfo1PortParam = (const float*)data;
Step-Sequencer.c:181:13:            self->lfo2PortParam = (const float*)data;
Step-Sequencer.c:184:13:            self->noteModeParam = (const float*)data;
Step-Sequencer.c:187:13:            self->modeParam = (const float*)data;
Step-Sequencer.c:190:13:            self->divisionParam = (const float*)data;
Step-Sequencer.c:193:13:            self->noteLengthParam = (const float*)data;
Step-Sequencer.c:196:13:            self->octaveSpreadParam = (const float*)data;
Step-Sequencer.c:199:13:            self->latchTransposeParam = (const float*)data;
Step-Sequencer.c:202:13:            self->swingParam = (const float*)data;
Step-Sequencer.c:205:13:            self->randomizeTimmingParam = (const float*)data;
Step-Sequencer.c:208:13:            self->velocityModeParam = (const float*)data;
Step-Sequencer.c:211:13:            self->velocityCurveParam = (const float*)data;
Step-Sequencer.c:214:13:            self->curveDepthParam = (const float*)data;
Step-Sequencer.c:217:13:            self->curveClipParam = (const float*)data;
Step-Sequencer.c:220:13:            self->curveLengthParam = (const float*)data;
Step-Sequencer.c:223:13:            self->velocityPatternLengthParam = (const float*)data;
Step-Sequencer.c:226:13:            self->patternVel1Param = (const float*)data;
Step-Sequencer.c:229:13:            self->patternVel2Param = (const float*)data;
Step-Sequencer.c:232:13:            self->patternVel3Param = (const float*)data;
Step-Sequencer.c:235:13:            self->patternVel4Param = (const float*)data;
Step-Sequencer.c:238:13:            self->patternVel5Param = (const float*)data;
Step-Sequencer.c:241:13:            self->patternVel6Param = (const float*)data;
Step-Sequencer.c:244:13:            self->patternVel7Param = (const float*)data;
Step-Sequencer.c:247:13:            self->patternVel8Param = (const float*)data;
Step-Sequencer.c:250:13:            self->lfo1ConnectParam = (const float*)data;
Step-Sequencer.c:253:13:            self->lfo1DepthParam = (const float*)data;
Step-Sequencer.c:256:13:            self->lfo2ConnectParam = (const float*)data;
Step-Sequencer.c:259:13:            self->lfo2DepthParam = (const float*)data;
Step-Sequencer.c:281:27:    msg.event.body.type = self->urid_midiEvent;
Step-Sequencer.c:321:9:        self->variables[parameters] = **self->parameters[parameters]; 
Step-Sequencer.c:325:19:    param = (int)*self->lfo1ConnectParam;
Step-Sequencer.c:327:47:        lfoValue = getParamMaxRange(param) * *self->lfo1DepthParam * *self->lfo1PortParam; 
Step-Sequencer.c:328:9:        self->variables[param] = **self->parameters[param] + lfoValue; 
Step-Sequencer.c:329:9:        self->variables[param] = applyRange(self->variables[param], getParamMinRange(param), getParamMaxRange(param));
Step-Sequencer.c:331:19:    param = (int)*self->lfo2ConnectParam;
Step-Sequencer.c:333:47:        lfoValue = getParamMaxRange(param) * *self->lfo2DepthParam * *self->lfo2PortParam; 
Step-Sequencer.c:334:9:        self->variables[param] = **self->parameters[param] + lfoValue; 
Step-Sequencer.c:335:9:        self->variables[param] = applyRange(self->variables[param], getParamMinRange(param), getParamMaxRange(param));
Step-Sequencer.c:339:5:    self->division           = self->variables[1];
Step-Sequencer.c:340:5:    self->noteLength         = self->variables[2];
Step-Sequencer.c:341:41:    //debug_print("note length = %f\n", self->noteLength);
Step-Sequencer.c:342:5:    self->octaveSpread       = self->variables[3];
Step-Sequencer.c:343:5:    self->swing              = self->variables[4];
Step-Sequencer.c:344:5:    self->randomizeTimming   = self->variables[5];
Step-Sequencer.c:345:5:    self->velocityMode       = (int)self->variables[6];
Step-Sequencer.c:346:5:    self->velocityCurve      = self->variables[7];
Step-Sequencer.c:347:5:    self->curveDepth         = self->variables[8];
Step-Sequencer.c:348:5:    self->curveClip          = self->variables[9];
Step-Sequencer.c:349:5:    self->velocityPattern[0] = (uint8_t)self->variables[10];
Step-Sequencer.c:350:5:    self->velocityPattern[1] = (uint8_t)self->variables[11];
Step-Sequencer.c:351:5:    self->velocityPattern[2] = (uint8_t)self->variables[12];
Step-Sequencer.c:352:5:    self->velocityPattern[3] = (uint8_t)self->variables[13];
Step-Sequencer.c:353:5:    self->velocityPattern[4] = (uint8_t)self->variables[14];
Step-Sequencer.c:354:5:    self->velocityPattern[5] = (uint8_t)self->variables[15];
Step-Sequencer.c:355:5:    self->velocityPattern[6] = (uint8_t)self->variables[16];
Step-Sequencer.c:356:5:    self->velocityPattern[7] = (uint8_t)self->variables[17];
Step-Sequencer.c:364:30:    const MetroURIs* uris = &self->uris;
Step-Sequencer.c:378:9:        self->bpm = ((LV2_Atom_Float*)bpm)->body;
Step-Sequencer.c:382:9:        self->speed = ((LV2_Atom_Float*)speed)->body;
Step-Sequencer.c:388:9:        self->beatInMeasure = ((LV2_Atom_Float*)beat)->body; 
Step-Sequencer.c:389:9:        self->barsize = beat_barsize; 
Step-Sequencer.c:391:13:        if (self->speed != previousSpeed) {
Step-Sequencer.c:392:13:            self->phase = beat_beats;
Step-Sequencer.c:393:29:            previousSpeed = self->speed;
Step-Sequencer.c:406:40:        lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, (LV2_Atom_Event*)&msg);
Step-Sequencer.c:414:19:    clearSequence(self->writeEvents);
Step-Sequencer.c:415:19:    clearSequence(self->playEvents);
Step-Sequencer.c:417:5:    self->writeEvents->used  = 0;
Step-Sequencer.c:418:5:    self->playEvents->used   = 0;
Step-Sequencer.c:419:5:    self->activeNotes        = 0;
Step-Sequencer.c:420:5:    self->transpose          = 0;
Step-Sequencer.c:421:5:    self->firstBar           = false;
Step-Sequencer.c:422:5:    self->trigger            = false;
Step-Sequencer.c:423:5:    self->octaveIndex        = 0;
Step-Sequencer.c:424:5:    self->notePlayed         = 0;
Step-Sequencer.c:425:5:    self->octaveIndex        = 0;
Step-Sequencer.c:426:5:    self->noteTie            = 0;
Step-Sequencer.c:429:9:        self->noteStarted[y] = 0;
Step-Sequencer.c:432:5:    self->noteOffIndex     = 0;
Step-Sequencer.c:433:5:    self->noteOffSendIndex = 0; 
Step-Sequencer.c:434:5:    self->activeNotes      = 0;
Step-Sequencer.c:435:5:    self->cleared          = true;
Step-Sequencer.c:443:34:    const uint32_t outCapacity = self->port_events_out1->atom.size;
Step-Sequencer.c:445:29:    lv2_atom_sequence_clear(self->port_events_out1);
Step-Sequencer.c:446:5:    self->port_events_out1->atom.type = self->port_events_in->atom.type;
Step-Sequencer.c:457:33:    different = checkDifference(self->playEvents->eventList, self->writeEvents->eventList, self->playEvents->used, self->writeEvents->used);
Step-Sequencer.c:461:20:        copyEvents(self->writeEvents, self->playEvents);  
Step-Sequencer.c:470:13:    return *self->randomizeTimmingParam * ((rand() % 100) * 0.003);
Step-Sequencer.c:477:27:    uint8_t octave = 12 * self->octaveIndex; 
Step-Sequencer.c:478:5:    self->octaveIndex = (self->octaveIndex + 1) % (int)self->octaveSpread;
Step-Sequencer.c:489:9:    if (self->velocityMode == 0) {
Step-Sequencer.c:490:9:        self->velocity = 80;
Step-Sequencer.c:491:16:    } else if (self->velocityMode == 1) { 
Step-Sequencer.c:492:9:        self->velocity = 127 + (int)floor(((self->velocityLFO) - 127) * self->curveDepth);
Step-Sequencer.c:493:16:    } else if (self->velocityMode == 2) {
Step-Sequencer.c:494:9:        self->velocity = floor(self->velocityPattern[self->patternIndex]);
Step-Sequencer.c:497:5:    self->patternIndex = (self->patternIndex + 1) % (int)*self->velocityPatternLengthParam; 
Step-Sequencer.c:499:9:    if (self->clip)
Step-Sequencer.c:500:9:        self->clip = false;
Step-Sequencer.c:502:12:    return self->velocity;
Step-Sequencer.c:512:10:    if ( self->playEvents->eventList[self->notePlayed][0] > 0 && self->playEvents->eventList[self->notePlayed][0] < 128)
Step-Sequencer.c:518:28:        uint8_t midiNote = self->playEvents->eventList[self->notePlayed][0] + self->transpose + octave;
Step-Sequencer.c:522:26:            if ((uint8_t)self->noteOffTimer[i][0] == midiNote) { 
Step-Sequencer.c:523:17:                self->noteOffTimer[i][1] = 0;
Step-Sequencer.c:536:44:            lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, (LV2_Atom_Event*)&onMsg);
Step-Sequencer.c:538:17:            if (self->noteTie > 0) {
Step-Sequencer.c:540:71:                LV2_Atom_MIDI noteTieMsg = createMidiEvent(self, 128, self->noteTie, 0);
Step-Sequencer.c:541:48:                lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, (LV2_Atom_Event*)&noteTieMsg);
Step-Sequencer.c:542:17:                self->noteTie = 0;
Step-Sequencer.c:545:17:            if (self->playEvents->eventList[self->notePlayed][1] != 2) { 
Step-Sequencer.c:546:17:                self->noteOffTimer[activeNoteIndex][0] = (float)midiNote;
Step-Sequencer.c:549:17:                self->noteTie = midiNote;
Step-Sequencer.c:556:16:    } else if (self->noteTie > 0) {
Step-Sequencer.c:558:63:        LV2_Atom_MIDI noteTieMsg = createMidiEvent(self, 128, self->noteTie, 0);
Step-Sequencer.c:559:40:        lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, (LV2_Atom_Event*)&noteTieMsg);
Step-Sequencer.c:560:9:        self->noteTie = 0;
Step-Sequencer.c:564:5:    self->cleared = false;
Step-Sequencer.c:565:5:    self->trigger = true;
Step-Sequencer.c:568:5:    self->notePlayed++;
Step-Sequencer.c:569:5:    self->notePlayed = (self->notePlayed > (self->playEvents->used - 1)) ? 0 : self->notePlayed;
Step-Sequencer.c:578:13:        if (self->noteOffTimer[i][0] > 0) {
Step-Sequencer.c:579:13:            self->noteOffTimer[i][1] += self->frequency / self->rate;
Step-Sequencer.c:580:17:            if (self->noteOffTimer[i][1] > self->noteLength) {
Step-Sequencer.c:581:76:                LV2_Atom_MIDI offMsg = createMidiEvent(self, 128, (uint8_t)self->noteOffTimer[i][0], 0);
Step-Sequencer.c:582:48:                lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, (LV2_Atom_Event*)&offMsg);
Step-Sequencer.c:583:17:                self->noteOffTimer[i][0] = 0;
Step-Sequencer.c:584:17:                self->noteOffTimer[i][1] = 0;
Step-Sequencer.c:595:36:    ModeEnum modeStatus    = (int)*self->modeParam;
Step-Sequencer.c:597:15:    if ((int)*self->modeParam != self->prevMod || (int)*self->latchTransposeParam != self->prevLatch) 
Step-Sequencer.c:604:17:                self->playing    = false;
Step-Sequencer.c:605:17:                self->modeHandle = 0;
Step-Sequencer.c:606:17:                self->through    = true; 
Step-Sequencer.c:609:17:                self->playing    = false;
Step-Sequencer.c:610:17:                self->modeHandle = 0;
Step-Sequencer.c:611:17:                self->through    = true; 
Step-Sequencer.c:612:17:                self->notePlayed = 0;
Step-Sequencer.c:615:17:                self->firstRecordedNote = false;
Step-Sequencer.c:616:17:                self->through           = true; 
Step-Sequencer.c:617:17:                self->modeHandle        = 6;  
Step-Sequencer.c:621:21:                if (self->writeEvents->used > 0)
Step-Sequencer.c:622:21:                    self->playing = true;
Step-Sequencer.c:625:27:                if ((int)*self->latchTransposeParam == 1 && self->playing == true) {
Step-Sequencer.c:626:21:                    self->modeHandle = 3;
Step-Sequencer.c:627:21:                    self->through = false;
Step-Sequencer.c:629:32:                else if ((int)*self->latchTransposeParam == 0 ) {
Step-Sequencer.c:630:21:                    self->modeHandle = 5; 
Step-Sequencer.c:631:21:                    self->through = false;
Step-Sequencer.c:632:21:                    self->playing = false;
Step-Sequencer.c:635:21:                    self->through = true;
Step-Sequencer.c:636:21:                    self->modeHandle = 0;
Step-Sequencer.c:640:17:                self->modeHandle    = 2;
Step-Sequencer.c:641:17:                self->through = false;
Step-Sequencer.c:643:27:                if ((int)*self->latchTransposeParam == 0 ) {
Step-Sequencer.c:644:21:                    self->through = false;
Step-Sequencer.c:645:21:                    self->playing = false;
Step-Sequencer.c:648:21:                    self->playing = true;
Step-Sequencer.c:652:17:                self->modeHandle    = 1;
Step-Sequencer.c:653:17:                self->through = false;
Step-Sequencer.c:655:27:                if ((int)*self->latchTransposeParam == 0 ) {
Step-Sequencer.c:656:21:                    self->playing = false;
Step-Sequencer.c:659:21:                    self->playing = true;
Step-Sequencer.c:664:17:                self->writeEvents->used--;
Step-Sequencer.c:667:9:        self->prevMod = (int)*self->modeParam;
Step-Sequencer.c:668:9:        self->prevLatch = (int)*self->latchTransposeParam;
Step-Sequencer.c:670:14:    //  if (*self->noteModeParam == 0) {
Step-Sequencer.c:674:12:    return self->modeHandle;
Step-Sequencer.c:688:9:        self->notesPressed++;  
Step-Sequencer.c:690:23:        if ((uint8_t)*self->noteModeParam == 0)
Step-Sequencer.c:700:28:                insertNote(self->writeEvents, midiNote, (uint8_t)*self->noteModeParam);
Step-Sequencer.c:701:17:                self->playing=true;
Step-Sequencer.c:705:17:                self->playing = true;
Step-Sequencer.c:706:17:                self->writeEvents->eventList[self->count++ % self->writeEvents->used][0] = midiNote;
Step-Sequencer.c:707:17:                self->writeEvents->eventList[self->count][1] = (uint8_t)*self->noteModeParam; 
Step-Sequencer.c:711:21:                    self->transpose = midiNote - self->writeEvents->eventList[0][0];
Step-Sequencer.c:715:28:                insertNote(self->writeEvents, 200, (uint8_t)*self->noteModeParam);
Step-Sequencer.c:718:17:                self->playing = true;
Step-Sequencer.c:719:17:                self->transpose = midiNote - self->writeEvents->eventList[0][0];
Step-Sequencer.c:722:22:                if (!self->firstRecordedNote) {
Step-Sequencer.c:723:21:                    self->playing = false;
Step-Sequencer.c:725:32:                    insertNote(self->writeEvents, midiNote, (uint8_t)*self->noteModeParam);
Step-Sequencer.c:726:21:                    self->firstRecordedNote = true;
Step-Sequencer.c:728:32:                    insertNote(self->writeEvents, midiNote, (uint8_t)*self->noteModeParam);
Step-Sequencer.c:735:9:        self->notesPressed--;
Step-Sequencer.c:736:71:        if ((modeHandle == 5 || modeHandle == 2 || modeHandle == 1)&& self->notesPressed == 0 && *self->latchTransposeParam == 0) {
Step-Sequencer.c:737:28:            //debug_print("self->playing=false");
Step-Sequencer.c:738:13:            self->playing = false;
Step-Sequencer.c:739:13:            self->notePlayed = 0;
Step-Sequencer.c:746:9:    if (self->through && (int)*self->noteModeParam > 0.0) {
Step-Sequencer.c:747:9:        self->midiThroughInput[self->inputIndex++ % 16] = msg[1]; 
Step-Sequencer.c:748:40:        lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, ev);
Step-Sequencer.c:749:9:        self->prevThrough = 1;
Step-Sequencer.c:751:14:    else if (self->prevThrough == 1) {
Step-Sequencer.c:752:32:        for (size_t i = 0; i < self->inputIndex + 1; i++) {
Step-Sequencer.c:755:63:            LV2_Atom_MIDI offMsg = createMidiEvent(self, 128, self->midiThroughInput[i], 0);
Step-Sequencer.c:756:44:            lv2_atom_sequence_append_event(self->port_events_out1, outCapacity, (LV2_Atom_Event*)&offMsg);
Step-Sequencer.c:758:9:        self->inputIndex  = 0;
Step-Sequencer.c:759:9:        self->prevThrough = 0;
Step-Sequencer.c:771:5:    self->notePlacement[1] = self->swing * 0.01;
Step-Sequencer.c:773:9:    if (self->playing && self->firstBar)
Step-Sequencer.c:776:13:        if (self->phase >= self->notePlacement[self->placementIndex] && self->phase < (self->notePlacement[self->placementIndex] + 0.2)
Step-Sequencer.c:777:21:                && !self->trigger && self->playEvents->used > 0)
Step-Sequencer.c:779:53:            debug_print("check for note at = %f\n", self->beatInMeasure);
Step-Sequencer.c:781:13:            self->triggerSet = false;
Step-Sequencer.c:783:32:        { //if this is false: (self->phase < 0.2 && !trigger && self->writeEvents->used > 0)
Step-Sequencer.c:784:17:            if (self->phase > self->notePlacement[self->placementIndex] + 0.2 && !self->triggerSet)
Step-Sequencer.c:786:17:                self->placementIndex ^= 1;
Step-Sequencer.c:787:17:                self->trigger = false;
Step-Sequencer.c:789:17:                self->triggerSet = true;
Step-Sequencer.c:804:31:    LV2_ATOM_SEQUENCE_FOREACH(self->port_events_in, ev)
Step-Sequencer.c:806:30:        if (ev->body.type == self->urid_midiEvent)
Step-Sequencer.c:820:5:    self->port_events_out1->atom.type = self->port_events_in->atom.type;
Step-Sequencer.c:822:30:    const MetroURIs* uris = &self->uris;
Step-Sequencer.c:825:39:    const LV2_Atom_Sequence* in     = self->control;
Step-Sequencer.c:840:5:    self->frequency = calculateFrequency(self->bpm, self->division);
Step-Sequencer.c:842:9:    if (self->frequency > self->nyquist)
Step-Sequencer.c:843:9:        self->frequency = self->frequency / 2;
Step-Sequencer.c:853:9:        self->phase = *phaseOsc(self->frequency, &self->phase, self->rate, self->swing);
Step-Sequencer.c:854:9:        self->velocityLFO = *velOsc(self->frequency, &self->velocityLFO, self->rate, self->velocityCurve, self->curveDepth,
Step-Sequencer.c:855:17:                self->curveLengthParam, self->curveClip, self);

oscillators.c:47:14:    m1 = a / self->x1;
oscillators.c:48:20:    m2 = a / ( a - self->x1 );
oscillators.c:50:8:    if(self->velPhase < self->x1) {
oscillators.c:51:26:        warpedpos = m1 * self->velPhase;
oscillators.c:54:27:        warpedpos = (m2 * self->velPhase * -1) + m2;
oscillators.c:59:39:        if (*velocityLFO >= 126.88 || self->clip)
oscillators.c:62:13:            self->clip = true;
oscillators.c:63:21:        } else if (!self->clip) {
oscillators.c:68:5:    self->velPhase+=velOscPhase;
oscillators.c:70:12:    while (self->velPhase >= phaseLenght) {
oscillators.c:71:9:        self->velPhase-= phaseLenght;
oscillators.c:72:9:        self->x1 = (self->velocityCurve > 0) ? self->velocityCurve * 0.01 : 0.00000009;
